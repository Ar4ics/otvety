<HTML>
<HEAD>
<TITLE>Вариант №121 тестовых заданий для будущих магистров потока МПО  </TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<SCRIPT language=JavaScript>
<!-- Original: Monichar -->

<!-- This script and many more are available free online at -->
<!-- The JavaScript Source!! http://javascript.internet.com -->

<!-- Begin
var ans = new Array;
var done = new Array;
var score = 0;
ans[1] = "b";
ans[2] = "e";
ans[3] = "b";
ans[4] = "c";
ans[5] = "d";
ans[6] = "f";
ans[7] = "b";
ans[8] = "b";
ans[9] = "c";
ans[10] = "g";
ans[11] = "d";
ans[12] = "d";
ans[13] = "c";
ans[14] = "d";
ans[15] = "c";
ans[16] = "e";
ans[17] = "e";
ans[18] = "e";
ans[19] = "c";
ans[20] = "d";
function Engine(question, answer) {
if (answer != ans[question]) {
if (!done[question]) {
done[question] = -1;
alert("Ошибка!\n\nВаш счет: " + score);
}
else {
alert("Вы уже отвечали на это!");
}
}
else {
if (!done[question]) {
done[question] = -1;
score++;
alert("Правильно!\n\nСейчас Ваш счет: " + score);
}
else { 
alert("Вы уже ответили на это!");
}
}
}
// End -->
</SCRIPT>
</HEAD>

<BODY text=black bgColor=white background="oboifon.jpg">

<H2>Вариант №121</H2>

<P><B>1. Важнейший принцип структурного программирования базируется на утверждении: </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(1, this.value)" type=radio value=a>
любой алгоритм имеет дискретную структуру 
<BR><INPUT onclick="Engine(1, this.value)" type=radio value=b>
алгоритм любой сложности можно построить с помощью следующих базовых структур: линейной, ветвящейся, циклической 
<BR><INPUT onclick="Engine(1, this.value)" type=radio value=c>
современный компьютер – это единство аппаратных средств и программного обеспечения 
<BR><INPUT onclick="Engine(1, this.value)" type=radio value=d>
сущность формализации решаемой задачи заключается в составлении алгоритма 
<BR><INPUT onclick="Engine(1, this.value)" type=radio value=e>
в качестве обязательного этапа создания программы выступает ее тестирование и отладка


<P><B>2. Определенный интеграл &#8747;F(x)dx от подынтегральной функции F(x)  с пределами 
интегрирования от a до b можно приближенно вычислить, если поделить 
отрезок [a,b] на n интервалов (F<sub>0</sub>=F(a), F<sub>n</sub>=F(b)) и применить следующую 
 <I>формулу левых прямогульников</I>:  
 </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(2, this.value)" type=radio value=a>
&#8747;F(x)dx &#8776; 
[F<sub>0</sub> + F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub> + F<sub>n</sub>]&#183;(b&ndash;a)/n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=b>
&#8747;F(x)dx &#8776; 
[F<sub>0</sub> + F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub> + F<sub>n</sub>]&#183;(b&ndash;a)/2n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=c>
&#8747;F(x)dx &#8776; 
[ F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub> + F<sub>n</sub>]&#183;(b&ndash;a)/n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=d>
&#8747;F(x)dx &#8776; 
[ F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub> + F<sub>n</sub>]&#183;(b&ndash;a)/2n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=e>
&#8747;F(x)dx &#8776; 
[F<sub>0</sub> + F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub>]&#183;(b&ndash;a)/n 

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=f>
&#8747;F(x)dx &#8776; 
[F<sub>0</sub> + F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub>]&#183;(b&ndash;a)/2n 

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=g>
&#8747;F(x)dx &#8776; 
[F<sub>0</sub>/2 + F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... +  F<sub>n&ndash;1</sub> + F<sub>n</sub>/2]&#183;(b&ndash;a)/n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=h>
&#8747;F(x)dx &#8776; [F<sub>0</sub> + 4 F<sub>1</sub> + 2F<sub>2</sub> + 4F<sub>3</sub> + 2 F<sub>4</sub> + 
... 4 F<sub>n&ndash;1</sub> + F<sub>n</sub>]&#183;(b&ndash;a)/2n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=i>
&#8747;F(x)dx &#8776; [F<sub>0</sub> + 4 F<sub>1</sub> + 2F<sub>2</sub> + 4F<sub>3</sub> + 2 F<sub>4</sub> + 
... 4 F<sub>n&ndash;1</sub> + F<sub>n</sub>]&#183;(b&ndash;a)/3n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=j>
&#8747;F(x)dx &#8776; {F[(x<sub>1</sub> &ndash; x<sub>0</sub>)/2 + 
F[(x<sub>2</sub> &ndash; x<sub>1</sub>)/2 + F[(x<sub>3</sub> &ndash; x<sub>2</sub>)/2 + ... 
+ F[(x<sub>n</sub> &ndash; x<sub>n &ndash;1</sub>)/2}&#183;(b&ndash;a)/n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=k>
&#8747;F(x)dx &#8776; {F[(x<sub>1</sub> &ndash; x<sub>0</sub>)/2 + 
F[(x<sub>2</sub> &ndash; x<sub>1</sub>)/2 + F[(x<sub>3</sub> &ndash; x<sub>2</sub>)/2 + ... 
+ F[(x<sub>n</sub> &ndash; x<sub>n &ndash;1</sub>)/2}&#183;(b&ndash;a)/2n

<BR><INPUT onclick="Engine(2, this.value)" type=radio value=l>
&#8747;F(x)dx &#8776; {F[(x<sub>1</sub> &ndash; x<sub>0</sub>)/2 + 
F[(x<sub>2</sub> &ndash; x<sub>1</sub>)/2 + F[(x<sub>3</sub> &ndash; x<sub>2</sub>)/2 + ... 
+ F[(x<sub>n</sub> &ndash; x<sub>n &ndash;1</sub>)/2}&#183;(b&ndash;a)/3n



<P><B>3. Пусть a и b &ndash;  два приближенных числа, &#916;a, &#916;b &ndash; их абсолютные погрешности. 
Какая из приведенных ниже формул неверная ? 
</B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(3, this.value)" type=radio value=a>
&#916;(a + b) = &#916;a + &#916;b
<BR><INPUT onclick="Engine(3, this.value)" type=radio value=b>
&#916;(a &ndash; b) = &#916;a &ndash; &#916;b
<BR><INPUT onclick="Engine(3, this.value)" type=radio value=c>
&#916;(a&#183;b) = a&#916;b + b&#916;a
<BR><INPUT onclick="Engine(3, this.value)" type=radio value=d>
&#916;(a/b) = (a&#916;b + b&#916;a)/b<SUP>2</SUP>
<BR><INPUT onclick="Engine(3, this.value)" type=radio value=e>
&#916;(a &ndash; b) = &#916;a + &#916;b


<P><B>4. Способ находить по известному приближению решения следующее, более точное приближение &ndash; </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(4, this.value)" type=radio value=a>
обратный ход 
<BR><INPUT onclick="Engine(4, this.value)" type=radio value=b>
прямой ход 
<BR><INPUT onclick="Engine(4, this.value)" type=radio value=c>
простая итерация 
<BR><INPUT onclick="Engine(4, this.value)" type=radio value=d>
двойной пересчет 
<BR><INPUT onclick="Engine(4, this.value)" type=radio value=e>
аппроксимация 

<P><B>5. Оценка точности и достоверности результатов имитационного моделирования производится на основе </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(5, this.value)" type=radio value=a>
проверки результатов расчета руководителем организации 
<BR><INPUT onclick="Engine(5, this.value)" type=radio value=b>
анализа и интерпретации результатов имитационных экспериментов с моделями 
<BR><INPUT onclick="Engine(5, this.value)" type=radio value=c>
сопоставления полученных результатов с данными других авторов 
<BR><INPUT onclick="Engine(5, this.value)" type=radio value=d>
сопоставления результатов расчетов с экспериментальными данными 
<BR><INPUT onclick="Engine(5, this.value)" type=radio value=e>
проверки и последующей корректировки экспериментальных данных 


<P><B>6.  По какой формуле может вычисляться функция y=e<SUP>2x</SUP>?
</B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(6, this.value)" type=radio value=a>
 y=exp(2x) 
<BR><INPUT onclick="Engine(6, this.value)" type=radio value=b>
 y=e^2*x 
<BR><INPUT onclick="Engine(6, this.value)" type=radio value=c>
 y=e^(2*x) 
<BR><INPUT onclick="Engine(6, this.value)" type=radio value=d>
 y=exp^2*x 
<BR><INPUT onclick="Engine(6, this.value)" type=radio value=e>
 y=exp^(2*x) 
<BR><INPUT onclick="Engine(6, this.value)" type=radio value=f>
 y=exp(2*x) 

<P><B>7. Какая из приведенных формул является формулой 
итерационного процесса метода Ньютона решения уравнения f(x)=0?   
</B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(7, this.value)" type=radio value=a>
x<sub>i+1</sub> = x<sub>i</sub> &#8722; f&#180;(x<sub>i</sub>) &#8260; f(x<sub>i</sub>), i=1,2,...
<BR><INPUT onclick="Engine(7, this.value)" type=radio value=b>
x<sub>i+1</sub> = x<sub>i</sub> &#8722; f(x<sub>i</sub>) &#8260; f&#180;(x<sub>i</sub>), i=0,1,2,...
<BR><INPUT onclick="Engine(7, this.value)" type=radio value=c>
x<sub>i+1</sub> = &ndash;x<sub>i</sub> &#8722; f&#180;(x<sub>i</sub>) &#8260; f(x<sub>i</sub>), i=0,1,2,...
<BR><INPUT onclick="Engine(7, this.value)" type=radio value=d>
x<sub>i</sub> = x<sub>i+1</sub> &#8722; f(x<sub>i+1</sub>) &#8260; f&#180;(x<sub>i</sub>), i=1,2,...
<BR><INPUT onclick="Engine(7, this.value)" type=radio value=e>
x<sub>i+1</sub> = x<sub>i</sub> + f(x<sub>i</sub>) &#8260; f&#180;(x<sub>i</sub>), i=1,2,...


<P><B>8.  Значения материальных постоянных a,b в модели вида y=ax+b могут 
быть определены из заданного набора экспериментальных данных
 {x<SUB>i</SUB>,y<SUB>i</SUB>}, i=1,2,…,N путем минимизации следующей целевой функции    </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(8, this.value)" type=radio value=a>
Ф(a,b)=&#8721;[y<SUB>i</SUB> &ndash; ax<SUB>i</SUB> &ndash; b]
<BR><INPUT onclick="Engine(8, this.value)" type=radio value=b>
Ф(a,b)=&#8721;[ax<SUB>i</SUB> + b &ndash; y<SUB>i</SUB>]<SUP>2</SUP>
<BR><INPUT onclick="Engine(8, this.value)" type=radio value=c>
Ф(a,b)=&#8721;[&ndash;ax<SUB>i</SUB> + b &ndash; y<SUB>i</SUB>]<SUP>2</SUP>
<BR><INPUT onclick="Engine(8, this.value)" type=radio value=d>
Ф(a,b)=&#8721;[ax<SUB>i</SUB> + b + y<SUB>i</SUB>]<SUP>2</SUP>
<BR><INPUT onclick="Engine(8, this.value)" type=radio value=e>
Ф(a,b)=&#8721;[ax<SUB>i</SUB> + b &ndash; y<SUB>i</SUB>]




<P><B>9.  Идея метода золотого сечения заключается: </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(9, this.value)" type=radio value=a>
в вычислении как значения функции качества, так и её первых частных производных 
<BR><INPUT onclick="Engine(9, this.value)" type=radio value=b>
выполнении операций отражения, растяжения, сжатия и редукции над многогранником 
<BR><INPUT onclick="Engine(9, this.value)" type=radio value=c>
в организации процедуры последовательного деления интервала неопределённости с использованием решающего правила, позволяющего выделить новый, уменьшённый интервал неопределённости 
<BR><INPUT onclick="Engine(9, this.value)" type=radio value=d>
в устранении (фильтрации) погрешностей в исходной информации 
<BR><INPUT onclick="Engine(9, this.value)" type=radio value=e>
в замене (приближении) исходной функции некоторой другой функцией, которую можно вычислить на ЭВМ 


<P><B>10. Расстояние между точками А(2,3) и В(5,7) равно  </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=a>
1 
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=b>
4 
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=c>
5 
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=d>
6 
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=e>
7 
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=f>
17 
<BR><INPUT onclick="Engine(10, this.value)" type=radio value=g>
25 

<P><B>11.  Условием перпендикулярности двух прямых  y=k<sub>1</sub>x+b<sub>1</sub> и  
y=k<sub>2</sub>x+b<sub>2</sub>  является:
</B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(11, this.value)" type=radio value=a>
k<sub>1</sub> = k<sub>2</sub>

<BR><INPUT onclick="Engine(11, this.value)" type=radio value=b>
k<sub>1</sub> = &ndash; k<sub>2</sub>

<BR><INPUT onclick="Engine(11, this.value)" type=radio value=c>
k<sub>1</sub>&#183;k<sub>2</sub> = 1

<BR><INPUT onclick="Engine(11, this.value)" type=radio value=d>
k<sub>1</sub>&#183;k<sub>2</sub> = &ndash; 1

<BR><INPUT onclick="Engine(11, this.value)" type=radio value=e>
k<sub>1</sub> + k<sub>2</sub> = 1


<P><B>12.  Полюс полярной системы координат совмещен с началом декартовой системы координат, а полярная ось совпадает с положительной полуосью абсцисс. Тогда точка  
(3,y), заданная в декартовой системе координат, имеет полярный радиус &#961;=5 при  y, равном:
</B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(12, this.value)" type=radio value=a>
&#177;1
<BR><INPUT onclick="Engine(12, this.value)" type=radio value=b>
&#177;2
<BR><INPUT onclick="Engine(12, this.value)" type=radio value=c>
&#177;3
<BR><INPUT onclick="Engine(12, this.value)" type=radio value=d>
&#177;4
<BR><INPUT onclick="Engine(12, this.value)" type=radio value=e>
&#177;5


<P><B>13.  Полуоси эллипса  25x<SUP>2</SUP> + 
9y <SUP>2</SUP> = 1 
 равны:
 </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(13, this.value)" type=radio value=a>
5 и 3
<BR><INPUT onclick="Engine(13, this.value)" type=radio value=b>
25 и 9
<BR><INPUT onclick="Engine(13, this.value)" type=radio value=c>
1/5 и 1/3
<BR><INPUT onclick="Engine(13, this.value)" type=radio value=d>
1/25 и 1/9
<BR><INPUT onclick="Engine(13, this.value)" type=radio value=e>
у эллипса полуосей не бывает (только оси)


<P><B>14.  Уравнение плоскости, проходящей через начало координат, имеет вид: </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(14, this.value)" type=radio value=a>
x + 5 = 0
<BR><INPUT onclick="Engine(14, this.value)" type=radio value=b>
4х + 6y + 5z  = 3
<BR><INPUT onclick="Engine(14, this.value)" type=radio value=c>
3y + 5z  = 1
<BR><INPUT onclick="Engine(14, this.value)" type=radio value=d>
4х + 6y + 8z = 0
<BR><INPUT onclick="Engine(14, this.value)" type=radio value=e>
ax<SUP>2</SUP> + bx + c = 0



<P><B>15.  В какой из формул дифференцирования допущена ошибка? </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(15, this.value)" type=radio value=a>
(u + v)&#8242; = u&#8242; + v&#8242;
<BR><INPUT onclick="Engine(15, this.value)" type=radio value=b>
(uv)&#8242; = u&#8242;v + uv&#8242;
<BR><INPUT onclick="Engine(15, this.value)" type=radio value=c>
(u/v)&#8242; = (u&#8242;v + uv&#8242;) / v<SUP>2</SUP>
<BR><INPUT onclick="Engine(15, this.value)" type=radio value=d>
(u &ndash; v)&#8242; = u&#8242; &ndash; v&#8242;
<BR><INPUT onclick="Engine(15, this.value)" type=radio value=e>
(&#8730;u)&#8242; = u&#8242;/2&#8730;u
<BR><INPUT onclick="Engine(15, this.value)" type=radio value=f>
все формулы верные

<P><B>16.  Под понятием "оптимизация" в вычислительной математике понимают: </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(16, this.value)" type=radio value=a>
процесс выбора решения приближенного к нулю 
<BR><INPUT onclick="Engine(16, this.value)" type=radio value=b>
процесс нахождения улучшающих последовательностей 
<BR><INPUT onclick="Engine(16, this.value)" type=radio value=c>
математический метод, состоящий в замене одних математических объектов другими 
<BR><INPUT onclick="Engine(16, this.value)" type=radio value=d>
процесс выбора решения, значение которого очень близко к нулю 
<BR><INPUT onclick="Engine(16, this.value)" type=radio value=e>
процесс выбора наилучшего решения из множества возможных 


<P><B>17.  Условием существования точки перегиба функции   y=f(x) при x = x<sub>0</sub>  является:
</B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(17, this.value)" type=radio value=a>
f&#8242;(x<sub>0</sub>) &#60; 0
<BR><INPUT onclick="Engine(17, this.value)" type=radio value=b>
f&#8242;(x<sub>0</sub>) = 0
<BR><INPUT onclick="Engine(17, this.value)" type=radio value=c>
f&#8242;(x<sub>0</sub>) &#62; 0
<BR><INPUT onclick="Engine(17, this.value)" type=radio value=d>
f&#8243;(x<sub>0</sub>) &#60; 0
<BR><INPUT onclick="Engine(17, this.value)" type=radio value=e>
f&#8243;(x<sub>0</sub>) = 0
<BR><INPUT onclick="Engine(17, this.value)" type=radio value=f>
f&#8243;(x<sub>0</sub>) &#62; 0


<P><B>18.  Первым замечательным пределом называется предел вида: </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(18, this.value)" type=radio value=a>
lim<sub>x&#8594;&#8734;</sub>sinx/x = 0
<BR><INPUT onclick="Engine(18, this.value)" type=radio value=b>
lim<sub>x&#8594;&#8734;</sub>sinx/x = 1
<BR><INPUT onclick="Engine(18, this.value)" type=radio value=c>
lim<sub>x&#8594;&#8734;</sub>sinx/x = e
<BR><INPUT onclick="Engine(18, this.value)" type=radio value=d>
lim<sub>x&#8594;0</sub>sinx/x = 0
<BR><INPUT onclick="Engine(18, this.value)" type=radio value=e>
lim<sub>x&#8594;0</sub>sinx/x = 1
<BR><INPUT onclick="Engine(18, this.value)" type=radio value=f>
lim<sub>x&#8594;0</sub>sinx/x = e


<P><B>19.  Задачи, в которых требуется исследовать функционал на максимум или минимум, называются </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(19, this.value)" type=radio value=a>
экстремальными задачами 
<BR><INPUT onclick="Engine(19, this.value)" type=radio value=b>
задачами идентификации 
<BR><INPUT onclick="Engine(19, this.value)" type=radio value=c>
вариационными задачами 
<BR><INPUT onclick="Engine(19, this.value)" type=radio value=d>
задачами минимакса 
<BR><INPUT onclick="Engine(19, this.value)" type=radio value=e>
задачами оптимизации 


<P><B>20.  Выберите верное утверждение: </B>
<p><I>Ответы</I>
<BR><INPUT onclick="Engine(20, this.value)" type=radio value=a>
Обратная матрица существует для квадратной матрицы, определитель которой равен нулю 
<BR><INPUT onclick="Engine(20, this.value)" type=radio value=b>
Обратная матрица существует для любой квадратной матрицы 
<BR><INPUT onclick="Engine(20, this.value)" type=radio value=c>
Произведение матриц A·B существует если количество столбцов матрицы A равно количеству строк матрицы B 
<BR><INPUT onclick="Engine(20, this.value)" type=radio value=d>
Произведение матриц A·B существует если количество строк матрицы A равно количеству столбцов матрицы B 
<BR><INPUT onclick="Engine(20, this.value)" type=radio value=e>
Произведение матриц A·B существует только для квадратных матриц A и B 



<P><A HREF="../Критерии оценки.htm">Критерии оценки</A>

</td></tr></table>


</body>
</html>
